// @bun
import{EventEmitter as p}from"events";class b extends p{url;protocols;ws=null;isConnected=!1;constructor(e,s){super();this.url=e;this.protocols=s;this.connect()}connect(){try{this.ws=new WebSocket(this.url,this.protocols),this.ws.onopen=()=>{this.isConnected=!0,this.emit("open")},this.ws.onerror=(e)=>{this.isConnected=!1,this.emit("error",e)},this.ws.onclose=()=>{this.isConnected=!1,this.emit("close")},this.ws.onmessage=(e)=>{this.emit("message",e.data)}}catch(e){this.emit("error",e)}}send(e){if(this.ws?.readyState===WebSocket.OPEN)this.ws.send(e)}close(){if(this.ws)this.ws.close(),this.ws=null;this.isConnected=!1}get connected(){return this.isConnected}}import{EventEmitter as B}from"events";class d extends B{clients=new Map;constructor(e){super();Bun.serve({hostname:e.hostname,port:e.port,fetch:async(s,n)=>{if(this.emit("fetch",s),s.headers.get("upgrade")==="websocket"){let i=Bun.randomUUIDv7(),o=s.url,t=s.headers.get("sec-websocket-protocol")||void 0,h=s.headers.get("authorization")||void 0,l=s.headers.get("user-agent")||void 0;n.upgrade(s,{data:{sessionId:i,route:o,protocol:t,authorization:h,userAgent:l}}),this.emit("upgrade",{sessionId:i,route:o,protocol:t,authorization:h,userAgent:l})}},websocket:{open:(s)=>{let n=s.data;this.clients.set(n.sessionId,s),this.emit("open",n)},message:(s,n)=>{let i=s.data;this.emit("message",i,n)},close:(s)=>{let{sessionId:n}=s.data;this.clients.delete(n),this.emit("close",n)}}})}connect(e){}send(e,s){this.clients.get(e)?.send(s)}close(e){this.clients.get(e)?.close()}}import{EventEmitter as C}from"events";class f extends C{props;server;routes=new Map;clients=new Map;proxies=new Map;constructor(e){super();this.props=e;this.server=new d({hostname:this.props.hostname,port:this.props.port}),this.server.on("upgrade",(s)=>{this.onUpgrade(s)}),this.server.on("message",(s,n)=>{this.onMessage(s,n)})}static matchRouter=({route:e,input:s,target:n})=>{try{let i=new URL(e,"http://localhost"),o=new URL(s),t=new URL(n),[h]=[i.pathname,i.search],[l,m]=[o.pathname,o.search],[u]=[t.pathname,t.search],v=h.split("/").filter(Boolean),r=l.split("/").filter(Boolean),W=u.split("/").filter(Boolean);if(r.length!==v.length)return{match:!1};if(!v.every((c,S)=>c===r[S]||c.startsWith(":")))return{match:!1};let w={};v.forEach((c,S)=>{if(c.startsWith(":"))w[c]=r[S]});let k=W.map((c)=>w[c]||c);return{match:!0,output:t.origin+"/"+k.join("/")+m}}catch(i){return console.error(i),{match:!1}}};async createClientProxy({sessionId:e,href:s,protocol:n}){let i=new b(s,n);i.on("open",()=>{this.server.connect(e)}),i.on("close",()=>{this.server.close(e)}),i.on("message",(o)=>{this.server.send(e,o)}),this.clients.set(e,i)}async onUpgrade(e){Array.from(this.routes.keys()).forEach((n)=>{let i=this.routes.get(e.route);if(!i)return;let o=f.matchRouter({route:n,input:e.route,target:i});if(o.output)this.createClientProxy({sessionId:e.sessionId,href:o.output,protocol:e.protocol})})}async onMessage(e,s){this.clients.get(e.sessionId)?.send(s),this.proxies.get(e.sessionId)?.send(s)}route(e,s){return this.routes.set(e,s),this}}export{d as WebsocketServer,f as WebsocketProxy,b as WebsocketClient};
